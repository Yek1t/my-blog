---
title: 死锁
date: 2021-4-20
tags:
 - 锁
categories:
 - 操作系统
---

# 死锁产生的四个必要条件
## 1.互斥条件
## 2.占有并等待条件
## 3.环路等待条件
## 4.不抢占条件

****

# 死锁解决策略：
## 1. 死锁预防
### 主要的思想：提前破坏死锁产生的四个必要条件，静态地避免死锁发生。
 - **破坏互斥条件**：把某些互斥访问的资源改造成共享资源（SPOOLing技术）。  
 缺点：可行性不高
 - **破坏占有并等待条件**：  
 方法一：在进程执行前，一次性分配进程所需的全部资源，如果资源得不到满足，则不分配任何资源，暂不执行。  
 方法二：只有当进程不占有资源时才分配给进程资源。进程可以占有一部分资源，但是当它向os索取更多资源的时候必须先释放当前占有的全部资源。  
 缺点：进程动态执行，难以事先预知进程所需的全部资源；资源利用率低；可能会导致饥饿。
 - **破坏不抢占条件**：  
方法一：申请的资源得不到满足时则立即释放当前所拥有的全部资源。  
方法二：由操作系统干预按照优先级从别的进程那里剥夺某些资源。  
缺点：实现复杂；强行剥夺可能会导致进程失效；反复申请和释放导致系统性能较低；可能导致饥饿。  
 - **破坏环路条件**：  
给所有资源排序编号，所有进程对资源的申请必须按照严格递增的顺序提出，每次只能申请序号更大的资源，防止产生环路。  
缺点：导致资源浪费，不方便加入新资源。

## 2. 死锁避免
### 避免死锁同样属于事先预防策略，但并不是事先采取某种限制措施破坏死锁的必要条件，而是在资源动态分配过程中，防止资源进入不安全状态，以避免发生死锁。这种方式所施加的限制条件较弱，可以获得较好的系统性能。  
 - **系统安全状态**：避免死锁的方法中允许进程动态地申请资源，但系统在进行资源分配之前，应先计算此次分配的安全性。若此次分配不会导致系统进行不安全状态，则允许分配，否则让进程等待。  
 并非所有的不安全状态都是死锁状态，但当系统进入不安全状态后，便可能进入死锁状态。反之，只要系统处于安全状态，系统便可避免进入死锁状态。  
 - **银行家算法**：算法要做的是判断对请求的满足是否会导致进入不安全状态。如果是，就推迟对这一请求的满足；如果满足请求后系统仍然是安全的，就予以分配。

## 3. 死锁检测
### 利用资源分配图来描述系统资源的分配情况。
 - **死锁定理**：如果资源分配图中没有环路，则系统没有死锁；如果资源分配图中出现了环路，则系统可能有死锁。

## 4. 死锁解除
 - **资源剥夺法**：  
 挂起某些死锁资源，抢占其资源分配给其他的死锁进程。  
 缺点：被挂起的进程可能会导致饥饿。  
 - **终止进程法**：  
 强制终止部分、甚至全部死锁进程，并剥夺其所占有的资源。  
 缺点：付出代价较大，有些进程已近结束，终止就会功亏一篑。
 - **进程回退法**：  
 让一个或多个进程回退到不会发生死锁的地步。  
 缺点：要求系统记录进程的历史信息，设置还原点，浪费系统资源。
