(window.webpackJsonp=window.webpackJsonp||[]).push([[22],{687:function(t,r,_){"use strict";_.r(r);var a=_(32),s=Object(a.a)({},(function(){var t=this,r=t.$createElement,_=t._self._c||r;return _("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[_("h1",{attrs:{id:"死锁产生的四个必要条件"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#死锁产生的四个必要条件"}},[t._v("#")]),t._v(" 死锁产生的四个必要条件")]),t._v(" "),_("h2",{attrs:{id:"_1-互斥条件"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-互斥条件"}},[t._v("#")]),t._v(" 1.互斥条件")]),t._v(" "),_("h2",{attrs:{id:"_2-占有并等待条件"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-占有并等待条件"}},[t._v("#")]),t._v(" 2.占有并等待条件")]),t._v(" "),_("h2",{attrs:{id:"_3-环路等待条件"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3-环路等待条件"}},[t._v("#")]),t._v(" 3.环路等待条件")]),t._v(" "),_("h2",{attrs:{id:"_4-不抢占条件"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_4-不抢占条件"}},[t._v("#")]),t._v(" 4.不抢占条件")]),t._v(" "),_("hr"),t._v(" "),_("h1",{attrs:{id:"死锁解决策略"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#死锁解决策略"}},[t._v("#")]),t._v(" 死锁解决策略：")]),t._v(" "),_("h2",{attrs:{id:"_1-死锁预防"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-死锁预防"}},[t._v("#")]),t._v(" 1. 死锁预防")]),t._v(" "),_("h3",{attrs:{id:"主要的思想-提前破坏死锁产生的四个必要条件-静态地避免死锁发生。"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#主要的思想-提前破坏死锁产生的四个必要条件-静态地避免死锁发生。"}},[t._v("#")]),t._v(" 主要的思想：提前破坏死锁产生的四个必要条件，静态地避免死锁发生。")]),t._v(" "),_("ul",[_("li",[_("strong",[t._v("破坏互斥条件")]),t._v("：把某些互斥访问的资源改造成共享资源（SPOOLing技术）。"),_("br"),t._v("\n缺点：可行性不高")]),t._v(" "),_("li",[_("strong",[t._v("破坏占有并等待条件")]),t._v("："),_("br"),t._v("\n方法一：在进程执行前，一次性分配进程所需的全部资源，如果资源得不到满足，则不分配任何资源，暂不执行。"),_("br"),t._v("\n方法二：只有当进程不占有资源时才分配给进程资源。进程可以占有一部分资源，但是当它向os索取更多资源的时候必须先释放当前占有的全部资源。"),_("br"),t._v("\n缺点：进程动态执行，难以事先预知进程所需的全部资源；资源利用率低；可能会导致饥饿。")]),t._v(" "),_("li",[_("strong",[t._v("破坏不抢占条件")]),t._v("："),_("br"),t._v("\n方法一：申请的资源得不到满足时则立即释放当前所拥有的全部资源。"),_("br"),t._v("\n方法二：由操作系统干预按照优先级从别的进程那里剥夺某些资源。"),_("br"),t._v("\n缺点：实现复杂；强行剥夺可能会导致进程失效；反复申请和释放导致系统性能较低；可能导致饥饿。")]),t._v(" "),_("li",[_("strong",[t._v("破坏环路条件")]),t._v("："),_("br"),t._v("\n给所有资源排序编号，所有进程对资源的申请必须按照严格递增的顺序提出，每次只能申请序号更大的资源，防止产生环路。"),_("br"),t._v("\n缺点：导致资源浪费，不方便加入新资源。")])]),t._v(" "),_("h2",{attrs:{id:"_2-死锁避免"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-死锁避免"}},[t._v("#")]),t._v(" 2. 死锁避免")]),t._v(" "),_("h3",{attrs:{id:"避免死锁同样属于事先预防策略-但并不是事先采取某种限制措施破坏死锁的必要条件-而是在资源动态分配过程中-防止资源进入不安全状态-以避免发生死锁。这种方式所施加的限制条件较弱-可以获得较好的系统性能。"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#避免死锁同样属于事先预防策略-但并不是事先采取某种限制措施破坏死锁的必要条件-而是在资源动态分配过程中-防止资源进入不安全状态-以避免发生死锁。这种方式所施加的限制条件较弱-可以获得较好的系统性能。"}},[t._v("#")]),t._v(" 避免死锁同样属于事先预防策略，但并不是事先采取某种限制措施破坏死锁的必要条件，而是在资源动态分配过程中，防止资源进入不安全状态，以避免发生死锁。这种方式所施加的限制条件较弱，可以获得较好的系统性能。")]),t._v(" "),_("ul",[_("li",[_("strong",[t._v("系统安全状态")]),t._v("：避免死锁的方法中允许进程动态地申请资源，但系统在进行资源分配之前，应先计算此次分配的安全性。若此次分配不会导致系统进行不安全状态，则允许分配，否则让进程等待。"),_("br"),t._v("\n并非所有的不安全状态都是死锁状态，但当系统进入不安全状态后，便可能进入死锁状态。反之，只要系统处于安全状态，系统便可避免进入死锁状态。")]),t._v(" "),_("li",[_("strong",[t._v("银行家算法")]),t._v("：算法要做的是判断对请求的满足是否会导致进入不安全状态。如果是，就推迟对这一请求的满足；如果满足请求后系统仍然是安全的，就予以分配。")])]),t._v(" "),_("h2",{attrs:{id:"_3-死锁检测"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3-死锁检测"}},[t._v("#")]),t._v(" 3. 死锁检测")]),t._v(" "),_("h3",{attrs:{id:"利用资源分配图来描述系统资源的分配情况。"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#利用资源分配图来描述系统资源的分配情况。"}},[t._v("#")]),t._v(" 利用资源分配图来描述系统资源的分配情况。")]),t._v(" "),_("ul",[_("li",[_("strong",[t._v("死锁定理")]),t._v("：如果资源分配图中没有环路，则系统没有死锁；如果资源分配图中出现了环路，则系统可能有死锁。")])]),t._v(" "),_("h2",{attrs:{id:"_4-死锁解除"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_4-死锁解除"}},[t._v("#")]),t._v(" 4. 死锁解除")]),t._v(" "),_("ul",[_("li",[_("strong",[t._v("资源剥夺法")]),t._v("："),_("br"),t._v("\n挂起某些死锁资源，抢占其资源分配给其他的死锁进程。"),_("br"),t._v("\n缺点：被挂起的进程可能会导致饥饿。")]),t._v(" "),_("li",[_("strong",[t._v("终止进程法")]),t._v("："),_("br"),t._v("\n强制终止部分、甚至全部死锁进程，并剥夺其所占有的资源。"),_("br"),t._v("\n缺点：付出代价较大，有些进程已近结束，终止就会功亏一篑。")]),t._v(" "),_("li",[_("strong",[t._v("进程回退法")]),t._v("："),_("br"),t._v("\n让一个或多个进程回退到不会发生死锁的地步。"),_("br"),t._v("\n缺点：要求系统记录进程的历史信息，设置还原点，浪费系统资源。")])])])}),[],!1,null,null,null);r.default=s.exports}}]);