(window.webpackJsonp=window.webpackJsonp||[]).push([[20],{683:function(t,a,r){"use strict";r.r(a);var s=r(32),e=Object(s.a)({},(function(){var t=this,a=t.$createElement,r=t._self._c||a;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("h2",{attrs:{id:"堆"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#堆"}},[t._v("#")]),t._v(" 堆：")]),t._v(" "),r("p",[t._v("堆主要存放Java在运行过程中new出来的对象，凡是通过new生成的对象都存放在堆中，对于堆中的对象生命周期的管理由Java虚拟机的垃圾回收机制GC进行回收和统一管理。类的非静态成员变量也放在堆区，其中基本数据类型是直接保存值，而复杂类型是保存指向对象的引用，非静态成员变量在类的实例化时开辟空间并且初始化。加载——连接——初始化——实例化。")]),t._v(" "),r("h2",{attrs:{id:"栈"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#栈"}},[t._v("#")]),t._v(" 栈：")]),t._v(" "),r("p",[t._v("栈主要存放运行期间用到的一些局部变量（基本数据类型的变量）或者是指向其他对象的一些引用，因为方法执行时，被分配的内存就在栈中，所以存储的局部变量就在栈中。当一段代码或者一个方法被调用完毕后，栈中为这段代码所提供的的基本数据类型或者对象的引用就立即被释放。")]),t._v(" "),r("h2",{attrs:{id:"常量池"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#常量池"}},[t._v("#")]),t._v(" 常量池：")]),t._v(" "),r("p",[t._v("常量池是方法区的一部分内存。常量池在编译期间就将一部分数据存放于该区域，包含基本数据类型若int，long等以final声明的常量值，和String字符串、特别注意的是对于方法运行期位于栈中的局部变量String常量的值可以通过 String.intern()方法将该值置入常量池中。")]),t._v(" "),r("h2",{attrs:{id:"静态域"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#静态域"}},[t._v("#")]),t._v(" 静态域：")]),t._v(" "),r("p",[t._v("位于方法区的一部分内存。存放类中以static声明的静态成员变量。")]),t._v(" "),r("h2",{attrs:{id:"方法区"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#方法区"}},[t._v("#")]),t._v(" 方法区：")]),t._v(" "),r("p",[t._v("是各个线程共享的内存区域，它用于存储class二进制文件，包含了虚拟机加载的类信息、常量、静态变量、即时编译后的代码等数据，它有个名字叫Non-Heap（非堆），目的是与Java堆区区别开。")])])}),[],!1,null,null,null);a.default=e.exports}}]);